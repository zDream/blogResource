title: oracle事务
date: 1/6/2016 8:54:18 AM 
tags: 数据库
---
## 事务隔离 ##

 1. 一个未提交的事务所做的修改不能被其它事务所看到。只有当事务提交成功后，在该事务之后执行的其它事务才可能看到该事务所做的改变。
 2. 在该事务提交之前已经执行了一部分而另一部分在该事务提交后执行的剩余部分同样也看不到该事务做出的改变。这是另一个Oracle特性：读一致和快照。
 3. 在该事务提交同时进行的其它事务同样也看不到该事务所做的改变

## 语句级回滚 ##

 1. 当一个SQL语句在执行期间因为发生的任何错误而中断时，将产生一个“语句级回滚”。该回滚的后果就像这个SQL语句根本没有执行过一样。
 2. 注意回滚是发生在“执行”阶段的，如果是在SQL语句的解析阶段因为语法问题而无法执行。因为没有产生任何影响而不会出现“回滚”。

## Oracle事务控制的分割 ##

 如果一个事务中包含了DML语句和DDL语句，那么该事务会被分解成多个事务。首先在DDL之前的所有DML语句会被作为一个事务而一次性提交。然后Oracle会为这个DDL创建一个新的，单语句的事务。如果DDL语句执行失败了，那么DML事务依然成功。 每个DDL语句单独成为一个事务，也就是说DDL语句不能回退。

## 不同情况下的Oracle事务控制 ##

 请注意：用户从Oracle服务器断开连接和用户进程强行中断的后果是不同的。
 1. 前者典型的例子是Oracle服务器关闭或重启，此时所有未提交事务会被提交。
 2. 后者典型的例子用户通过进程管理器强行kill掉进程，此时所有未提交事务所做的操作被回滚。

## 事务提交前要做的事情 ##

 Oracle提交一个事务之前，必须做以下几件事情：

 1. 记住数据被修改前是什么样子的
 2. 记住数据即将要被改成什么样子
 3. 记住redo log和undo log的关联
 4. 将SGA中已读取到内存的数据修改为新的值(此时并未真正保存到数据文件)

 其中第一步是通过在undo表空间中记录undo日志来完成的。第二步、第三步是通过向SGA中的redo日志缓冲区写记录来完成的。这样当事务回滚时就可以从redo日志找到对应的undo日志，从而找回之前的数据

 - **要特别注意的是：此时不一定会触发DBWn进程。**
 - **要特别注意的另一个地方是：第2步记录事务操作的改变是内存中进行的，还未写到磁盘上的redo日志文件**

## 事务提交时所做的事情 ##

 1. 记录SCN值(System Change Number)
 2. 将在线重做日志记录(位于SGA的redo日志缓冲区中)持久化到redo日志文件
 3. Oracle释放资源和锁
 4. Oracle将事务标记为已结束

 注意：只有在commit指令被发出后，才会将SGA中重做日志缓冲区的内容刷新到磁盘的redo日志文件。在LGWR进程执行前，重做日志一直存在于内存中，也被称为在线重做日志。

## savepoint回滚和整个事务的回滚 ##

 注意当Oracle事务回滚到某个savepoint时，在savepoint之后的所有后续savepoint将失效。但此时Transaction还是活跃且可继续的。这一点不同于整个事务的回滚。

## 自治事务 ##

 从传统上来说，一个事务只有在完整执行成功或回滚之后，才会进行下一个事务。而自治事务允许在一个事务中调用运行另一个事务，被调用事务执行完成后，调用事务继续执行之前未完成的操作直至事务结束  
 自治事务在被调用后，将和外围事务完全独立。彼此之间并不共享任何资源或者锁，外围事务所有未提交的改变对自治事务来说都是不可见。自治事务提交后外围事务将可以看到改变。