title: 二. 垃圾算法和HotSpot算法实现
date: 3/21/2018 11:00:30 PM 
tags: java虚拟机
---

## 一，对象已死吗? ##

在堆里存放着所有的java对象实例。如下算法判断哪个对象存活，哪个已经死去。

### 1. 引用计数算法 ###

概念：给对象添加一个引用计数器，每当有一个地方引用它时，计数器值就加1；当引用时，计数器就减1；任何计数器为0的对象就是不可能再被使用的。

算法实现简单，效率最高。

### 2. 可达性分析算法 ###

基本思想是通过一系统称为“GC Roots”的对象作为起始点，从这些节点开始向下搜索，搜索所走的路径称为引用链，当一个对象到 GC Roots 没有任何引用链相连时，则证明对象是不可用的。
在java语言中，可作为GC Roots的对象包括下面几种：

 - 虚拟机栈（栈帧中的本地变量表）中引用的对象。
 - 方法区中的类静态属性引用的对象
 - 方法区中常量引用的对象
 - 本地方法栈中JNI(即一般说的Native方法)引用的对象

### 3. 再谈引用 ###

无论是引用计数还是可达性分析，判定对象是否存活都与**引用**有关。
在jdk1.2以前，java对引用的定义：如果reference类型的数据中存储的数值代表的是另外一块内存的起始地址，则称为这块内存代表着一个引用。然尔这样有一些缺点：我们希望能描述这样一种对象：当内存空间还足够时，则能保存在内存这中；如果内存空间在进行垃圾收集后还是非常紧张，则可以抛弃这些对象。很多系统的缓存功能都符合这样的应用场景。

所以在jdk1.2之后，java对这些引用进行了扩充。分为如下类型，引用强度逐渐减弱：

 - **强引用**(Strong Reference):**是指在程序代码中普遍存在的**，只要强引用还存在，就永远不会回收到被引用的对象。比如 Object obj = new Object();
 - **软引用**(Soft Reference):**用来描述一些还有用但并非必须的对象**。在发生内存溢出异常之前，将会把这些对象列进回收范围之中进行第二次回收。如果这次还没有足够的内存，才会抛出内存溢出异常
 - **弱引用**(Weak Reference):**用来描述非必须的对象**。比软引用更弱一些。被弱引用关联的对象只能生存到下一次垃圾收集发生之前。当垃圾收集器工作时，无论当前内存是否足够，都会回收掉只被弱引用关联的对象。
 - **虚引用**(Phantom Reference):**称为幽灵引用或者幻影引用**，是最弱的一种引用。为一个对象设置虚引用关联的唯一目的就是能在这个对象被收集器回收时收到一个系统通知。

### 4. 回收方法区 ###
方法区又被人称为永久代

在方法区中进行垃圾收集的性价比比较低；在堆中尤其是在新生代中，一次垃圾收集一般可以 回收70%-95%的空间。

永久代垃圾收集主要回收两部分内容：废弃常量和无用的类。判定一个常量是否废弃比较简单。而要判定一个类是否是无用的类的条件相对苛刻许多。类需要满足以下3个条件：

 1. 该类所有的实例都已经被回收，也就是java堆 中不存在该类的任何实例
 2. 加载该类的ClassLoader已经被回收
 3. 该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。

## 二. 垃圾收集算法 ##

### 1. 标记-清除算法 ###

算法分为标记和清除两个阶段：首先标记出需要回收的对象，在标记完成后统一回收所有被标记的对象。

缺点：  

 1. 效率不高
 2. 空间问题。标记清除后会产生大量不连续的内存碎片，碎片太多可能会导致程序在运行过程中需要分配较大对象时，无法找到足够的连续内存而不得不提前触发一次垃圾收集动作。

### 2. 复制算法 ###

为解决效率问题，复制算法出现了：将内存按容量划分为大小相等的现场，每次只使用其中的一块，当这一块用完了，就将还存活的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。这样使得每次都是对整个半区进行回收，内存分配时也不用考虑内存碎片等复杂情况，只要移动堆顶指针，按顺序分配内存即可，实现简单，运行高效。只是这种算法的代价将内存缩小为了原来的一半，未免太高了一点。现在的商业模式都采用这种收集算法来回收新生代。

### 3. 标记-整理算法 ###

复制收集算法在对象存活率较高时就要进行较多我的复制操作，效率将会变低。更关键的是，如果不想浪费50%的空间，就需要额外的空间进行分配担保，以应对被使用的内存中所有对象都100%戚的极端情况，所以在老年代一般不能直接选用这种算法。

根据老年代的特点，提出了标记-整理算法，与标记清除算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有对象都向一端移动，然后直接清理掉端边界以外的内存。

### 4. 分代收集算法 ###

当前商业虚拟机的垃圾收集都采用分代收集算法，没有什么新的思想，一般把java堆分为新生代和老年代，这样就可以 根据各个年代的特点采用合适的收集算法。   在新生代中每次垃圾收集时都发现有大批对象死去，少量存活，就选用**复制算法**。而老年代中因为对象存活率高，没有额外空间对它进行担保，就必须使用 **标记-清理算法**，或者**标记整理算法**。

## 三. HotSpot算法实现 ##

### 1. 枚举根节点 ###

### 2. 安全点 ###

### 3. 安全区域 ###